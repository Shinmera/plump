<!DOCTYPE html> <html lang="EN"> <head> <meta charset="utf-8"> <title>Plump</title> <style>html body{margin:0 auto 0 auto;padding:20px;max-width:1024px;font-family:sans-serif;font-size:14pt;overflow-y:scroll;}html body a{text-decoration:none;}html body a[href]{color:#0055AA;}html body a[href]:hover{color:#0088EE;}html body pre{background:#FAFAFA;border:1px solid #DDDDDD;padding:0.75em;overflow-x:auto;}html body pre >code a[href]{color:#223388;}article.project h1{font-size:1.7em;}article.project h1,article.project h2,article.project h3,article.project h4,article.project h5,article.project h6{margin:0.2em 0 0.1em 0;text-indent:1em;}article.project >header{text-align:center;}article.project >header img.logo{display:block;margin:auto;max-height:170px;}article.project >header h1{display:inline-block;text-indent:0;font-size:2.5em;}article.project >header .version{vertical-align:bottom;}article.project >header .languages{margin-top:-0.5em;text-transform:capitalize;}article.project >header .description{margin:0;}article.project >header .pages{margin-top:0.5em;font-size:1.2em;text-transform:capitalize;}article.project >header .pages a{display:inline-block;padding:0 0.2em;}article.project >section{margin:1em 0 1em 0;}article.project >section img{max-width:100%;}article.project #index >ul{list-style:none;margin:0;padding:0;}article.project .row label{display:inline-block;min-width:8em;}article.project #system .row{display:flex;}article.project #system #dependencies{display:inline;margin:0;padding:0;}article.project #system #dependencies li{display:inline;padding:0 0.2em;}article.project #system #author label{vertical-align:top;}article.project #system #author ul{display:inline-block;margin:0;padding:0;list-style:none;}article.project #toc nav>*{margin-left:1em;display:block;}article.definition{margin:1em 0 0 0;}article.definition >header h1,article.definition >header h2,article.definition >header h3,article.definition >header h4,article.definition >header h5,article.definition >header h6{text-indent:0;display:inline-block;}article.definition >header ul{display:inline-block;list-style:none;margin:0;padding:0;}article.definition >header ul li{display:inline-block;padding:0 0.2em 0 0;}article.definition >header .visibility{display:none;}article.definition >header .visibility,article.definition >header .type{text-transform:lowercase;}article.definition >header .source-link{visibility:hidden;float:right;}article.definition >header .source-link:after{visibility:visible;content:"[SRC]";}article.definition .docstring{margin:0 0 0 1em;}article.definition .docstring pre{font-size:0.8em;white-space:pre-wrap;}.definition.package >header ul.nicknames{display:inline-block;list-style:none;margin:0;padding:0 0 0 1em;}.definition.package >header ul.nicknames li{display:inline;}.definition.package >header ul.nicknames:before{content:"(";}.definition.package >header ul.nicknames:after{content:")";}.definition.package ul.definitions{margin:0;list-style:none;padding:0 0 0 0.5em;}.definition.callable >header .name:before,.definition.type >header .name:before{content:"(";font-weight:normal;}.definition.callable >header .arguments:after,.definition.type >header .arguments:after{content:")";}.definition.callable >header .arguments .arguments:before,.definition.type >header .arguments .arguments:before{content:"(";}.definition.callable >header .arguments .argument,.definition.type >header .arguments .argument{padding:0;}.definition.callable >header .arguments .argument.lambda-list-keyword,.definition.type >header .arguments .argument.lambda-list-keyword{color:#991155;}.definition li>mark{background:none;border-left:0.3em solid #0088EE;padding-left:0.3em;display:block;}@media (min-width: 1300px){html body{padding-left:16em;}article.project #toc{margin:0;position:fixed;left:0;top:0;bottom:0;width:15em;overflow-y:auto;background:#F0F0F0;border-right:1px solid #A0A0A0;}}</style> </head> <body> <article class="project"> <header>  <img class="logo" src="plump-logo.png" alt="Logo">    <span class="version">2.0.0</span>    <p class="description">An XML / XHTML / HTML parser that aims to be as lenient as possible.</p>   </header> <section id="toc"> <h2>Table of Contents</h2> <nav> <a href="#project">Top</a>  <a href="#documentation">Documentation</a> <nav> <a href="#what_is_plump?">What is Plump?</a>  <a href="#how_to">How To</a>  <a href="#extending_plump">Extending Plump</a>  <a href="#plump's_lexer">Plump's Lexer</a>  <a href="#speed">Speed</a>  <a href="#see_also">See Also</a>  <a href="#support">Support</a> </nav>  <a href="#system">System</a>  </nav> </section>  <section id="documentation"><h2 id="what_is_plump?">What is Plump?</h2> <p>Plump is a parser for HTML/XML like documents, focusing on being lenient towards invalid markup. It can handle things like invalid attributes, bad closing tag order, unencoded entities, inexistent tag types, self-closing tags and so on. It parses documents to a class representation and offers a small set of DOM functions to manipulate it. You are free to change it to parse to your own classes though.</p> <h2 id="how_to">How To</h2> <p>Load Plump through Quicklisp or ASDF:</p> <pre><code>(ql:quickload :plump)
</code></pre> <p>Using the <code>PARSE</code> function, plump will transform a string, pathname or stream into a document:</p> <pre><code>(plump:parse &quot;&lt;foo&gt;&lt;bar this is=\&quot;a thing\&quot;&gt;baz&lt;/bar&gt;&lt;span id=\&quot;test\&quot;&gt;oh my&quot;)
</code></pre> <p>This returns a root node. If you want to append a document to a root node (or any other node that accepts children) that you've made, you can pass it into the parse function. To return the document into a readable form, you can call <code>SERIALIZE</code>:</p> <pre><code>(plump:serialize <a href="http://l1sp.org/cl/%2A" class="xref">*</a>)
</code></pre> <p>Using the DOM you can easily traverse the document and change it:</p> <pre><code>(plump:remove-child (plump:get-element-by-id <a href="http://l1sp.org/cl/%2A%2A" class="xref">**</a> &quot;test&quot;))
(plump:serialize <a href="http://l1sp.org/cl/%2A%2A%2A" class="xref">***</a>)
</code></pre> <p>By default plump includes a few special tag dispatchers to catch HTML oddities like self-closing tags and fulltext-nodes. Especially the self-closing tags can lead to problems in XML documents. In order to parse without any HTML &quot;tricks&quot;, you can simply do:</p> <pre><code>(let ((plump:*tag-dispatchers* plump:*xml-tags*)) (plump:parse &quot;&lt;link&gt;foo&lt;/link&gt;&quot;))
</code></pre> <p>This will also influence the serialization. By default self-closing tags will be printed in &quot;HTML-fashion,&quot; but if you require full XML support, the above should be the way to go. This behaviour is new in Plump2, as previously everything was always serialized in XML mode.</p> <h2 id="extending_plump">Extending Plump</h2> <p>If you want to handle a certain tag in a special way, you can write your own tag-dispatcher. For example comments, the doctype and self-closing tags are handled in this fashion. In order to properly hook in, you will have to learn to use Plump's lexer (see next section).</p> <pre><code>(plump:define-tag-dispatcher (my-dispatcher *tag-dispatchers*) (name)
  (<a href="http://l1sp.org/cl/string-equal" class="xref">string-equal</a> name &quot;my-tag&quot;))

(plump:define-tag-parser my-dispatcher (name)
  (let ((attrs (plump:read-attributes)))
    (<a href="http://l1sp.org/cl/when" class="xref">when</a> (<a href="http://l1sp.org/cl/char%3D" class="xref">char=</a> (plump:consume) #\/)
      (plump:consume)) ;; Consume closing
    (<a href="http://l1sp.org/cl/make-instance" class="xref">make-instance</a> 'my-tag :parent plump:*root* :attributes attrs)))
</code></pre> <p>If you don't want to disturb the standard Plump tag dispatchers list, you can define your own special variable to contain the dispatchers and bind <code>*tag-dispatchers*</code> to that during parsing, as shown for the XML example above. Shorthand macros exist to define self-closing or full-text tags:</p> <pre><code>(plump:define-self-closing-element img *tag-dispatchers* *html-tags*)
(plump:define-fulltext-element style *tag-dispatchers* *html-tags*)
</code></pre> <p>You can also define a wild card dispatcher for your own special variable that will dispatch on any tag that doesn't match another dispatcher:</p> <pre><code>(plump:define-wildcard-dispatcher your-default *your-special-variable*)
</code></pre> <p>XML allows for script tags (like <code>&lt;?php ?&gt;</code>). By default Plump does not specify any special reading for any script tag. If an unhandled script tag is encountered, a warning is emitted and Plump will try to just read anything until <code>?&gt;</code> is encountered. For most script tags this probably will not suffice, as they might contain some form of escaped <code>?&gt;</code>. If you do want to use Plump to process script tags properly as well, you will have to define your own reader with <code>define-processing-parser</code>. You can also use that macro to define a reader that outputs a more suitable format than a text tag.</p> <p>During parsing, all elements are created through <code>MAKE-*</code> functions like <code>MAKE-ROOT</code>, <code>MAKE-ELEMENT</code>, <code>MAKE-TEXT-NODE</code>, and so on. By overriding these functions you can instead delegate the parsing to your own DOM.</p> <p>If you subclass the DOM classes, you might want to define a method on <code>SERIALIZE-OBJECT</code> to produce the right output.</p> <h2 id="plump's_lexer">Plump's Lexer</h2> <p>Since parser generators are good for strict grammars and Plump needed to be fast and lenient, it comes with its own primitive reading/lexing mechanisms. All the lexer primitives are defined in <code>lexer.lisp</code> and you can leverage them for your own projects as well, if you so desire.</p> <p>In order to allow the lexing to work, you'll have to wrap your processing code in <code>with-lexer-environment</code>. You can then use functions like <code>consume</code>, <code>advance</code>, <code>unread</code>, <code>peek</code> and <code>consume-until</code> to process the input.</p> <p><code>make-matcher</code> allows you to use a very simple language to define matching operations. This will evaluate to a function with no arguments that should return <code><a href="http://l1sp.org/cl/t" class="xref">T</a></code> if it matches and <code>NIL</code> otherwise. Combining matchers with <code>consume-until</code> allows you to easily make sequence readers:</p> <pre><code>(plump:with-lexer-environment (&quot;&lt;foo&gt;&quot;)
  (when (char= #\&lt; (plump:consume))
    (plump:consume-until (plump:make-matcher (is #\&gt;)))))
</code></pre> <p>Available matcher constructs are <code><a href="http://l1sp.org/cl/not" class="xref">not</a></code>, <code><a href="http://l1sp.org/cl/and" class="xref">and</a></code>, <code><a href="http://l1sp.org/cl/or" class="xref">or</a></code>, <code>is</code>, <code>in</code>, <code>next</code>, <code>prev</code>, <code>any</code>, and <code><a href="http://l1sp.org/cl/find" class="xref">find</a></code>. <code>define-matcher</code> allows you to associate keywords to matchers, which you can then use as a matcher rule in <code>make-matcher</code>. Regular symbols act as variables:</p> <pre><code>(let ((find &quot;baz&quot;))
  (plump:with-lexer-environment (&quot;foo bar baz&quot;)
     (plump:consume-until (plump:make-matcher (is find)))))
</code></pre> <h2 id="speed">Speed</h2> <p><img src="http://shinmera.tymoon.eu/public/plump-benchmark.png" alt="benchmark"></p> <p>If you know of other native-lisp libraries that beat Plump, please do let me know, I would be very interested!</p> <h2 id="see_also">See Also</h2> <ul> <li><a href="https://shinmera.github.io/lquery/">lQuery</a> Dissect and manipulate the DOM with jQuery-like commands.</li> <li><a href="https://shinmera.github.io/CLSS/">CLSS</a> Traverse the DOM by CSS selectors.</li> <li><a href="https://github.com/Shinmera/plump-tex">plump-tex</a> Serialize between TeX and the Plump DOM.</li> <li><a href="https://github.com/Shinmera/plump-sexp">plump-sexp</a> Serialize between SEXPrs and the Plump DOM.</li> </ul> <h2 id="support">Support</h2> <p>If you'd like to support the continued development of Plump, please consider becoming a backer on Patreon:</p> <p><a href="https://patreon.com/shinmera"> <img alt="Patreon" src="https://filebox.tymoon.eu//file/TWpjeU9RPT0="> </a></p> </section>    <section id="system"> <h2>System Information</h2>  <div class="row"> <label for="version">Version:</label> <a id="version">2.0.0</a> </div>   <div class="row"> <label for="dependencies">Dependencies:</label> <ul id="dependencies"><li><a class="external" href="https://Shinmera.github.io/array-utils/">array-utils</a></li><li><a class="external" href="https://Shinmera.github.io/documentation-utils/">documentation-utils</a></li></ul> </div>   <div class="row" id="author"> <label for="author">Author:</label> <a href="mailto:shinmera@tymoon.eu">Yukari Hafner</a> </div>   <div class="row"> <label for="license">License:</label> <a id="license" href="https://github.com/Shinmera/plump/blob/9e61fe787c979d02154519c907b7874d369fe8d5/LICENSE">zlib</a> </div>   <div class="row"> <label for="homepage">Homepage:</label> <a id="homepage" href="https://Shinmera.github.io/plump/">https://Shinmera.github.io/plump/</a> </div>   <div class="row"> <label for="bug-tracker">Bug Tracker:</label> <a id="bug-tracker" href="https://github.com/Shinmera/plump/issues">https://github.com/Shinmera/plump/issues</a> </div>   <div class="row"> <label for="sources">Sources:</label> <a id="sources" href="https://github.com/Shinmera/plump.git">https://github.com/Shinmera/plump.git</a> </div>  </section>    </article> <script>window.addEventListener("DOMContentLoaded", function(){
    var unmarkElement = function(el){
        if(el.tagName === "mark" || el.tagName === "MARK"){
            [].forEach.call(el.childNodes, function(child){
                el.parentNode.insertBefore(child, el);
            });
            el.parentNode.removeChild(el);
        }else if(el.parentNode.tagName === "mark"){
            return unmarkElement(el.parentNode);
        }
        return null;
    }

    var unmarkAll = function(root){
        root = root || document;
        [].forEach.call(root.querySelectorAll("mark"), unmarkElement);
    }
    
    var markElement = function(el){
        if(el.parentNode.tagName === "mark" || el.parentNode.tagName === "MARK"){
            return el.parentNode;
        } else {
            unmarkAll();
            var marked = document.createElement("mark");
            el.parentNode.insertBefore(marked, el);
            marked.appendChild(el);
            return marked;
        }
    }

    var markFragmented = function(){
        if(window.location.hash){
            var el = document.getElementById(decodeURIComponent(window.location.hash.substr(1)));
            if(el) markElement(el);
        }
    }

    var registerXrefLink = function(link){
        var el = document.getElementById(decodeURIComponent(link.getAttribute("href").substr(1)));
        if(el){
            link.addEventListener("click", function(){
                markElement(el);
            });
        }
    }

    var registerXrefLinks = function(root){
        root = root || document;
        [].forEach.call(root.querySelectorAll("a.xref"), registerXrefLink);
    }

    markFragmented();
    registerXrefLinks();
}); </script> </body> </html> 